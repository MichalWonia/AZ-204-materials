âš–ï¸ Azure Cosmos DB Consistency Levels
Instead of offering just "Strong" vs. "Eventual" consistency, Azure Cosmos DB gives developers a spectrum of five consistency levels, 
allowing fine-grained control over the balance between performance, availability, and data accuracy.

ðŸ§ª The 5 Consistency Levels (from strongest âž¡ weakest)
ðŸ”’ Strong
- Reads always return the most recent committed write.
- Total global order of operations.
- Highest consistency, lowest availability.
- Similar to reading from a single-master system.

â³ Bounded Staleness
- Guarantees reads are behind writes by at most:
  - A certain number of operations (K),
  - OR a specific time interval (T seconds).
- Great for scenarios that require predictable lag.

ðŸ“± Session (Default)
- Guarantees read-your-own-writes within a session.
- Best option for single-user scoped apps (e.g., mobile apps, user dashboards).
- Strong consistency per session, eventual across sessions.

ðŸ“œ Consistent Prefix
- Reads never see out-of-order writes.
- If a write sequence is A â†’ B â†’ C, clients will never see B or C without first seeing A.
- No gaps, but some lag is possible.

ðŸŒ Eventual
- No ordering guarantees.
- Reads might return older data temporarily.
- Lowest latency, highest availability.

ðŸŒ Region-Agnostic Guarantees
Consistency is maintained regardless of:
ðŸŒ Number or location of regions (single or multi-region).
ðŸ“ Whether reads/writes are local or cross-region.
âœï¸ Whether your account uses single or multiple write regions.
ðŸ’¡ Read consistency applies per logical partition or partition-key range.

Azure Cosmos DB's flexible consistency model helps you tune performance without sacrificing the right amount of data correctness your app needs.



ðŸ› ï¸ Configuring Consistency
- Set at the account level, affects all containers and databases under that account.
- You can change it at any time.

Applies to reads scoped within a logical partition, regardless of whether the read comes from a client or stored procedure.

ðŸ“ Consistency Level Use Cases & Guarantees
1. ðŸ”’ Strong Consistency
âœ… Guarantees: Always returns the most recent committed write.
ðŸ“Œ Use when: Your app needs absolute correctness (e.g., banking systems).
âš ï¸ Tradeoff: Lower availability across regions, higher latency.

2. â±ï¸ Bounded Staleness
âœ… Guarantees: Reads lag behind writes by K versions or T seconds, whichever comes first.
ðŸ“Œ Use when: You want predictable lag but donâ€™t need real-time.
ðŸŒ Ideal for: Multi-region read scenarios (with single write region).
âš ï¸ Tradeoff: Slight delay in replication, writes may get throttled if lag exceeds limits.

3. ðŸ“± Session Consistency (Default)
âœ… Guarantees: "Read your own writes" and "write follows read" within a session.
ðŸ“Œ Use when: Users expect their actions (e.g., posting, updating) to reflect immediately in their own view.
ðŸ¤ Ideal for: User-centric apps like dashboards, chats, social media feeds.
âš ï¸ Tradeoff: Eventual consistency between sessions.

4. ðŸ“œ Consistent Prefix
âœ… Guarantees: No out-of-order reads; reads reflect a consistent sequence of writes.
ðŸ“Œ Use when: Order of operations is important but absolute freshness isnâ€™t.
ðŸ§¾ Example: Logs, inventory updates, sequential transactions.
âš ï¸ Tradeoff: May lag, but always in-order.

5. ðŸŒ Eventual Consistency
âœ… Guarantees: Replicas eventually convergeâ€”no ordering or freshness guarantee.
ðŸ“Œ Use when: Reads can be stale or unordered without affecting user experience.
ðŸ’¬ Examples: Likes, view counters, social metrics.
âš ï¸ Tradeoff: Highest availability and performance, but least strict consistency.

âœ… Summary Tips
- Use Strong when correctness > performance.
- Use Session for most user-driven apps.
- Use Eventual when speed and scale outweigh consistency (e.g., analytics).
- Use Bounded Staleness if you need a good balance across geo-distributed regions.
- Use Consistent Prefix when order matters more than freshness.

